/*
 * Component main file.
 */
#include <math.h>
#include "driver/timer.h"

// Component header file(s)
#include "mjd.h"
#include "mjd_scd30.h"

/*
 * Logging
 */
static const char TAG[] = "mjd_scd30";

/*
 * MAIN
 */

/*****
 * EU EN13779:
 * - EU EN13779 is the European Standard for ventilation and air conditioning in nonresidential buildings.
 * - Indoor air quality (IDA) is classified by levels of carbon dioxide present in the air
 *   and fresh air levels being introduced per person.
 *
 *    Category  Desc                        CO2 level ppm Outside Air m3/h/person
 *    --------  --------------------------- ------------- -----------------------
 *    IDA 1     High indoor air quality     < 400         > 54
 *    IDA 2     Medium indoor air quality   400 - 600     36 - 54
 *    IDA 3     Moderate indoor air quality 600 - 1000    22 - 36
 *    IDA 4     Low indoor air quality      > 1000        < 22
 */
static const char _EU_IDA_CATEGORY_CODE[4][MJD_SCD30_EU_IDA_CATEGORY_CODE_MAXLEN] =
            { "IDA 1", "IDA 2", "IDA 3", "IDA 4" };
static const char _EU_IDA_CATEGORY_DESC[4][MJD_SCD30_EU_IDA_CATEGORY_DESC_MAXLEN] =
            { "High indoor air quality", "Medium indoor air quality", "Moderate indoor air quality", "Low indoor air quality" };

mjd_scd30_eu_ida_category_t mjd_scd30_compute_eu_ida_category(float param_co2_ppm) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    mjd_scd30_eu_ida_category_t category = 0;

    if (param_co2_ppm < 400.0) {
        category = MJD_SCD30_EU_IDA_CATEGORY_1;
    } else if (param_co2_ppm <= 600.0) {
        category = MJD_SCD30_EU_IDA_CATEGORY_2;
    } else if (param_co2_ppm <= 1000.0) {
        category = MJD_SCD30_EU_IDA_CATEGORY_3;
    } else {
        category = MJD_SCD30_EU_IDA_CATEGORY_4;
    }

    return category;
}

esp_err_t mjd_scd30_get_ida_category_details(mjd_scd30_eu_ida_category_t param_category, char param_ptr_code[],
                                             char param_ptr_desc[]) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    if ((param_category < MJD_SCD30_EU_IDA_CATEGORY_1) || (param_category > MJD_SCD30_EU_IDA_CATEGORY_4)) {
        f_retval = ESP_ERR_INVALID_ARG;
        ESP_LOGE(TAG, "%s(). ABORT. param_category invalid value %u | err %i (%s)", __FUNCTION__, param_category,
                f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    strcpy(param_ptr_code, _EU_IDA_CATEGORY_CODE[param_category - 1]);
    strcpy(param_ptr_desc, _EU_IDA_CATEGORY_DESC[param_category - 1]);

    // LABEL
    cleanup: ;

    return f_retval;

}

/*****
 * Classification: CO2 ppm valid values range
 *
 * The returned CO2 ppm concentration must be within this range. Values outside this range must be rejected. Note that the 1st or 2nd read after a SoftReset sometimes returns 0.0 :(
 * @note Float values cannot be defined in an enum in the .h header file...
 */
static const float _MJD_SCD30_CO2_VALID_VALUE_MIN = 400.0;
static const float _MJD_SCD30_CO2_VALID_VALUE_MAX = 40000.0;

/*****
 * Event: Configuration Changed
 *
 * Reset the variable nbr of cmd_read_measurements
 *
 */
static uint32_t _nbr_of_cmd_read_measurements = 0; // Ignore read_measurement#1 and #2. The maximum value for UInt32 is 4.294.967.295 (0xFFFFFFFF).
#define MJD_SCD30_THIRD_CMD_READ_MEASUREMENT_IS_VALID (3) /*!<  */
static void _emit_event_configuration_changed() {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    _nbr_of_cmd_read_measurements = 0;
}

/*********************************************************************************
 * _delay_millisec()
 *
 *  @param millisec delay in ms
 *
 *  @important For long delays  (>= 500 millisec)    use vTaskDelay() instead of ets_delay_us() else the CPU Watchdog might be triggered.
 *  @important For small delays (< 500 milliseconds) use ets_delay_us() instead of vTaskDelay(). The RTOS func is not accurate enough.
 *
 */
static void _delay_millisec(uint32_t millisec) {
    if (millisec >= 500) {
        vTaskDelay(millisec / portTICK_PERIOD_MS);
    }
    else if (millisec > 0) {
        ets_delay_us(millisec * 1000);
    }
}

/*********************************************************************************
 * _check_crc()
 *
 * @return ESP_OK ESP_ERR_INVALID_CRC
 *
 * @doc (rx_buf+3, rx_buf[5]);
 *
 * @datasheet 4.12 Checksum Calculation
 *    The 8-bit CRC checksum transmitted after each data word is generated by a CRC algorithm. Its properties are displayed in Table 20.
 *    The CRC covers the contents of the two previously transmitted data bytes. To calculate the checksum only these two previously transmitted data bytes are used.
 *      Property        Value
 *      -------         --------
 *      Name            CRC-8
 *      Width           8 bit
 *      Protected data  read and/or write data
 *      Polynomial      0x31 (x8 + x5 + x4 + 1)
 *      Initialization  0xFF
 *      Reflect input   false
 *      Reflect output  false
 *      Final XOR       0x00
 *
 * Polynomial for CRC is 0x31 and not 0x131 (an 8-bit checksum can't use the 9th bit in the polynomial)
 *
 *  Example CRC (0xBEEF) = 0x92
 *
 *********************************************************************************/
static esp_err_t _compute_crc(uint8_t *param_computed_value, const uint8_t *param_data, int param_data_len) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    // calculates 8-Bit checksum with given polynomial
    const uint8_t POLYNOMIAL = 0x31;
    uint8_t crc = 0xFF; // @important initial value 0xFF
    for (uint8_t idx = 0; idx < param_data_len; idx++) {
        crc ^= (param_data[idx]);
        for (uint8_t bit = 8; bit > 0; --bit) {
            if (crc & 0x80) {
                crc = (crc << 1) ^ POLYNOMIAL;
            } else {
                crc = (crc << 1);
            }
        }
    }

    *param_computed_value = crc;

    return f_retval;
}

static esp_err_t _check_crc(uint8_t param_expected_value, const uint8_t *param_data, int param_len) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    uint8_t crc = 0;
    _compute_crc(&crc, param_data, param_len);
    if (crc != param_expected_value) {
        f_retval = ESP_ERR_INVALID_CRC;
    }

    return f_retval;
}

/*********************************************************************************
 * _log_config()
 *
 * @doc mjd_scd30_config_t
 *
 *********************************************************************************/
static esp_err_t _log_config(const mjd_scd30_config_t* param_ptr_config) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    ESP_LOGD(TAG, "LOG instance of mjd_scd30_config_t");

    ESP_LOGD(TAG, "  manage_i2c_driver:     %u", param_ptr_config->manage_i2c_driver);
    ESP_LOGD(TAG, "  i2c_port_num:          %u", param_ptr_config->i2c_port_num);
    ESP_LOGD(TAG, "  i2c_slave_addr:        0x%02X (%u)", param_ptr_config->i2c_slave_addr,
            param_ptr_config->i2c_slave_addr);
    ESP_LOGD(TAG, "  i2c_scl_gpio_num:      %u", param_ptr_config->i2c_scl_gpio_num);
    ESP_LOGD(TAG, "  i2c_sda_gpio_num:      %u", param_ptr_config->i2c_sda_gpio_num);
    ESP_LOGD(TAG, "  i2c_max_ticks_to_wait: %u", param_ptr_config->i2c_max_ticks_to_wait);

    ESP_LOGD(TAG, "  measurement_interval:  %u", param_ptr_config->measurement_interval);

    return f_retval;
}

/*********************************************************************************
 * _make_cmd_buffer()
 *
 *  Fill the TX buffer for an I2C Write-Command:
 *
 *  @param param_...
 *
 * Split the uint16_t param_command in two uint8_t's (MSB LSB)
 * The cmd_word requires no CRC.
 *
 *********************************************************************************/
static esp_err_t _make_cmd_buffer(uint8_t *param_ptr_buf, uint8_t *param_ptr_buf_len,
                                  const uint16_t param_command,
                                  const uint16_t *param_ptr_extra_input_data, const uint8_t param_extra_input_data_len) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);
    ESP_LOGD(TAG, "  param_extra_input_data_len: %u", param_extra_input_data_len);
    for (uint32_t j = 0; j < param_extra_input_data_len; j++) {
        ESP_LOGD(TAG, "  param_ptr_extra_input_data[%u]: 0x%04X %5u", j, param_ptr_extra_input_data[j],
                param_ptr_extra_input_data[j]);
    }

    esp_err_t f_retval = ESP_OK;

    uint8_t idx = 0;

    param_ptr_buf[idx++] = MJD_HIBYTE(param_command);
    param_ptr_buf[idx++] = MJD_LOBYTE(param_command);

    // TODO Add data[] and generate CRC's (not for the command-part)

    uint8_t crc = 0;
    for (uint8_t j = 0; j < param_extra_input_data_len; ++j) {
        param_ptr_buf[idx++] = MJD_HIBYTE(param_ptr_extra_input_data[j]);
        param_ptr_buf[idx++] = MJD_LOBYTE(param_ptr_extra_input_data[j]);

        f_retval = _compute_crc(&crc, &param_ptr_buf[idx - 2], 2);
        if (f_retval != ESP_OK) {
            ESP_LOGE(TAG, "%s(). ABORT. _compute_crc() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
            // GOTO
            goto cleanup;
        }
        param_ptr_buf[idx++] = crc;
    }

    // Save len
    *param_ptr_buf_len = idx;

    ESP_LOGD(TAG, "  param_ptr_buf_len: %u", *param_ptr_buf_len);

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * _i2c_write()
 *
 *  Exec an I2C Write transaction
 *
 *  @param param_...
 *
 * @important After each I2C Write a delay of MINIMUM *30* millisec is required (define MJD_SCD30_DELAY_MS_AFTER_I2C_WRITE)
 *             The device uses I2C clock-stretching (possibly before each ACK) so give some extra time to the device
 *             after an i2c-write and the upcoming i2c-read or another i2c-write.
 *
 *********************************************************************************/
static esp_err_t _i2c_write_bytes(const mjd_scd30_config_t* param_ptr_config,
                                  uint8_t *param_ptr_buf,
                                  const uint8_t param_buf_len) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);
    ESP_LOGD(TAG, "  param_buf_len: %u", param_buf_len);

    esp_err_t f_retval = ESP_OK;

    // Dump data to be transmitted
    for (uint32_t j = 0; j < param_buf_len; j++) {
        ESP_LOGD(TAG, "  param_ptr_buf[%u]: 0x%02X %3u", j, param_ptr_buf[j], param_ptr_buf[j]);
    }

    i2c_cmd_handle_t handle;
    handle = i2c_cmd_link_create();
    f_retval = i2c_master_start(handle);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. Send request i2c_master_start() err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    f_retval = i2c_master_write_byte(handle, (param_ptr_config->i2c_slave_addr << 1) | I2C_MASTER_WRITE, true);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. Send request i2c_master_write_byte() err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    f_retval = i2c_master_write(handle, param_ptr_buf, param_buf_len, true);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. Send request i2c_master_write() err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    f_retval = i2c_master_stop(handle);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. Receive response i2c_master_stop() err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    f_retval = i2c_master_cmd_begin(param_ptr_config->i2c_port_num, handle, param_ptr_config->i2c_max_ticks_to_wait);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. Receive response i2c_master_cmd_begin() err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // @important Delay after each I2C Write
    _delay_millisec(MJD_SCD30_DELAY_MS_AFTER_I2C_WRITE);

    // LABEL
    cleanup: ;

    i2c_cmd_link_delete(handle);

    return f_retval;
}

/*********************************************************************************
 * _send_cmd()
 *
 *   A command with no extra data to be sent and no extra data to be received.
 *
 *  @param param_...
 *
 * After sending a command to the sensor a minimal waiting time is needed before sending another command.
 *
 *********************************************************************************/
static esp_err_t _send_cmd(const mjd_scd30_config_t* param_ptr_config, const mjd_scd30_command_t param_command,
                           const uint16_t *param_ptr_input_data,
                           const uint8_t param_input_data_len) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);
    ESP_LOGD(TAG, "Device Send Command");
    ESP_LOGD(TAG, "  param_command: 0x%04X %u (sizeof=%zu)", param_command, param_command, sizeof(param_command));
    ESP_LOGD(TAG, "  param_input_data_len: %u", param_input_data_len);

    esp_err_t f_retval = ESP_OK;

    uint8_t tx_buf[MJD_SCD30_CMD_TX_BUF_SIZE + param_input_data_len * 2];
    uint8_t tx_buf_len = 0;

    f_retval = _make_cmd_buffer(tx_buf, &tx_buf_len, param_command, param_ptr_input_data, param_input_data_len);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. _make_cmd_buffer() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    f_retval = _i2c_write_bytes(param_ptr_config, tx_buf, tx_buf_len);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. _i2c_write() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * _i2c_read()
 *
 *  Exec an I2C Write transaction
 *
 *  @param param_...
 *
 *********************************************************************************/
static esp_err_t _i2c_read_bytes(const mjd_scd30_config_t* param_ptr_config,
                                 uint8_t *param_ptr_buf,
                                 uint8_t param_buf_len) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);
    ESP_LOGD(TAG, "  param_buf_len: %u", param_buf_len);

    esp_err_t f_retval = ESP_OK;
    i2c_cmd_handle_t handle;

    handle = i2c_cmd_link_create();
    f_retval = i2c_master_start(handle);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. Receive response i2c_master_start() err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    f_retval = i2c_master_write_byte(handle, (param_ptr_config->i2c_slave_addr << 1) | I2C_MASTER_READ, true);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. Receive response i2c_master_write_byte() err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        i2c_cmd_link_delete(handle);
        // GOTO
        goto cleanup;
    }
    // @doc i2c_master_read() param4=I2C_MASTER_LAST_NACK: do ACK for all reads except do NACK for the last read
    f_retval = i2c_master_read(handle, param_ptr_buf, param_buf_len, I2C_MASTER_LAST_NACK);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. Receive response i2c_master_read() err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        i2c_cmd_link_delete(handle);
        // GOTO
        goto cleanup;
    }
    f_retval = i2c_master_stop(handle);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. Receive response i2c_master_stop() err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        i2c_cmd_link_delete(handle);
        // GOTO
        goto cleanup;
    }

    f_retval = i2c_master_cmd_begin(param_ptr_config->i2c_port_num, handle, param_ptr_config->i2c_max_ticks_to_wait);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. Receive response i2c_master_cmd_begin() err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // Dump received data
    for (uint32_t j = 0; j < param_buf_len; j++) {
        ESP_LOGD(TAG, "  param_ptr_buf[%u]: 0x%02X %3u", j, param_ptr_buf[j], param_ptr_buf[j]);
    }

    // No delay required after I2C Read (device spec)

    // LABEL
    cleanup: ;

    i2c_cmd_link_delete(handle);

    return f_retval;
}

/*********************************************************************************
 * _receive_cmd()
 *
 *  To read out the content of one specific command (~a register address~): x times (3 bytes MSB LSB CRC) => x times (1 word).
 *
 *  Read an extra BYTE for each WORD, the byte contains the CRC
 *
 * @return The list of words (MSB+LSB), excluding the CRC byte
 *  TODO Provide funcs with uint8 and int16 return params
 *
 *********************************************************************************/
static esp_err_t _receive_cmd(const mjd_scd30_config_t* param_ptr_config, const mjd_scd30_command_t param_command,
                              uint16_t *param_ptr_output_data,
                              uint8_t param_output_data_len) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);
    ESP_LOGD(TAG, "Device Receive Command");
    ESP_LOGD(TAG, "  param_command:  0x%04X %u (sizeof=%zu)", param_command, param_command, sizeof(param_command));
    ESP_LOGD(TAG, "  param_output_data_len: %u", param_output_data_len);

    esp_err_t f_retval = ESP_OK;

    uint8_t tx_buf[MJD_SCD30_CMD_TX_BUF_SIZE] =
                { 0 };
    uint8_t tx_buf_len = 0;

    uint8_t rx_buf_len = 3 * param_output_data_len; // 2x nbr-of-words for MSB LSB, 1x nbr-of-words for CRC Byte
    uint8_t rx_buf[rx_buf_len];

    // Write
    f_retval = _make_cmd_buffer(tx_buf, &tx_buf_len, param_command, NULL, 0);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. _make_cmd_buffer() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    f_retval = _i2c_write_bytes(param_ptr_config, tx_buf, tx_buf_len);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. _i2c_write() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // Read
    f_retval = _i2c_read_bytes(param_ptr_config, rx_buf, rx_buf_len);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. _i2c_read_bytes() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // Check CRC's
    for (uint8_t j = 0; j < rx_buf_len; j += 3) {
        f_retval = _check_crc(rx_buf[j + 2], &rx_buf[j], 2);
        if (f_retval != ESP_OK) {
            ESP_LOGE(TAG, "%s(). ABORT. Invalid CRC, dataset j=%u rx_buf | err %i (%s)", __FUNCTION__, j, f_retval,
                    esp_err_to_name(f_retval));
            // GOTO
            goto cleanup;
        }
    }

    // Raw Bytes (MSB,LSB,CRC) to Words (MSB+LSB)
    //      @important Exclude CRC (each 3rd byte)
    if (param_output_data_len < rx_buf_len / 3) {
        f_retval = ESP_ERR_INVALID_SIZE;
        ESP_LOGE(TAG, "%s(). ABORT. param_output_data_len < rx_buf_len / 3 | err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    for (uint32_t j = 0; j < param_output_data_len; j++) {
        param_ptr_output_data[j] = ((uint16_t) rx_buf[j * 3] << 8) | (uint16_t) rx_buf[j * 3 + 1];
        ESP_LOGD(TAG, "  j: %u", j);
        ESP_LOGD(TAG, "  => param_ptr_output_data[%u]: 0x%04X %4u", j, param_ptr_output_data[j], param_ptr_output_data[j]);
    }

    // LABEL
    cleanup: ;

    return f_retval;
}

/**********
 **********
 * TODO SET functions: NONE for this device (The status register is read-only)
 *
 */

/*********************************************************************************
 * CMD Set Measurement Interval (for Continous Measurement)
 * @doc mjd_scd30_defs.h
 *
 * @param param_data seconds. param_data is a signed int by design so I can detect invalid negative numbers!
 *
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_set_measurement_interval(const mjd_scd30_config_t* param_ptr_config, int16_t param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */
    if (param_data < MJD_SCD30_MEASUREMENT_INTERVAL_MIN || param_data > MJD_SCD30_MEASUREMENT_INTERVAL_MAX) {
        f_retval = ESP_ERR_INVALID_ARG;
        ESP_LOGE(TAG, "%s(). ABORT. invalid input param value | err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Main
     */
    uint16_t word = param_data; // word

    f_retval = _send_cmd(param_ptr_config, MJD_SCD30_CMD_MEASUREMENT_INTERVAL, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _send_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Emit Event: Configuration Changed
     */
    _emit_event_configuration_changed();

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Get Measurement Interval
 * @doc mjd_scd30_defs.h
 *
 * @return
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_get_measurement_interval(const mjd_scd30_config_t* param_ptr_config, uint16_t* param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */

    /*
     * Main
     */
    uint16_t word; // word

    f_retval = _receive_cmd(param_ptr_config, MJD_SCD30_CMD_MEASUREMENT_INTERVAL, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _receive_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // Transform
    *param_data = word;

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Get Data Ready Status
 * @doc mjd_scd30_defs.h
 *
 * @return
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_get_data_ready_status(const mjd_scd30_config_t* param_ptr_config,
                                              mjd_scd30_data_ready_status_t * param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */

    /*
     * Main
     */
    uint16_t word; // word

    f_retval = _receive_cmd(param_ptr_config, MJD_SCD30_CMD_GET_DATA_READY_STATUS, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _receive_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // Transform
    *param_data = word;

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Set Automatic Self Calibration *ON or *OFF
 * @doc mjd_scd30_defs.h
 *
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_set_automatic_self_calibration(const mjd_scd30_config_t* param_ptr_config,
                                                       const mjd_scd30_asc_automatic_self_calibration_t param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */

    /*
     * Main
     */
    uint16_t word = param_data; // word

    f_retval = _send_cmd(param_ptr_config, MJD_SCD30_CMD_AUTOMATIC_SELF_CALIBRATION, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _send_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Emit Event: Configuration Changed
     */
    _emit_event_configuration_changed();

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Get Automatic Self Calibratio
 * @doc mjd_scd30_defs.h
 *
 * @return
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_get_automatic_self_calibration(const mjd_scd30_config_t* param_ptr_config,
                                                       mjd_scd30_asc_automatic_self_calibration_t* param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */

    /*
     * Main
     */
    uint16_t word; // word

    f_retval = _receive_cmd(param_ptr_config, MJD_SCD30_CMD_AUTOMATIC_SELF_CALIBRATION, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _receive_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // Transform
    *param_data = word;

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Set Forced Recalibration Value
 * @doc mjd_scd30_defs.h
 *
 * @param param_data ppm. param_data is a signed int by design so I can detect invalid negative numbers!
 *
 * @bug Calling this func is causing issues. Often the Command Trigger Continuous Measurement will not work anymore! Use at your own risk.
 *
 * @important It is recommended to run the Command SoftReset after calling this function.
 * @important Calling this func (not recommended) disables the ASC Automatic Self Calibration! So if you enable ASC again then that takes another 7 days to complete!
 *
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_set_forced_recalibration_value(const mjd_scd30_config_t* param_ptr_config, int16_t param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */
    if (param_data < MJD_SCD30_FORCED_RECALIBRATION_MIN || param_data > MJD_SCD30_FORCED_RECALIBRATION_MAX) {
        f_retval = ESP_ERR_INVALID_ARG;
        ESP_LOGE(TAG, "%s(). ABORT. invalid input param value | err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Main
     */
    uint16_t word = param_data; // word

    f_retval = _send_cmd(param_ptr_config, MJD_SCD30_CMD_FORCED_RECALIBRATION_VALUE, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _send_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Emit Event: Configuration Changed
     */
    _emit_event_configuration_changed();

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Get Forced Recalibration Value
 * @doc mjd_scd30_defs.h
 *
 * @return
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_get_forced_recalibration_value(const mjd_scd30_config_t* param_ptr_config, uint16_t* param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */

    /*
     * Main
     */
    uint16_t word; // word

    f_retval = _receive_cmd(param_ptr_config, MJD_SCD30_CMD_FORCED_RECALIBRATION_VALUE, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _receive_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // Transform
    *param_data = word;

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Set Temperature Offset
 * @doc mjd_scd30_defs.h
 *
 * @param param_data unit= °C x 100, i.e. one tick corresponds to 0.01°C. param_data is a signed int by design so I can detect invalid negative numbers!
 *
 * @doc Current default value = 100 for 1°C to compensate that the SCD30 board heating up the SHT31 temperature sensor.
 *      The value must be adapted for your environment.
 *
 * @important The on-board RH/T sensor is influenced by thermal self-heating of SCD30 and other electrical components.
 *    Design-in alters the thermal properties of SCD30 such that temperature and humidity offsets may occur when operating the sensor
 *    in end-customer devices. Compensation of those effects is achievable by writing the temperature offset found
 *    in continuous operation of the device into the sensor.
 *    Temperature offset value is saved in non-volatile memory.
 *    The last set value will be used for temperature offset compensation after repowering.
 *
 * @doc The offset influences the calculcation of the CO2 ppm, but it does not influence the reporting of the temperature sensor data itself.
 *
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_set_temperature_offset(const mjd_scd30_config_t* param_ptr_config, int16_t param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */
    if (param_data < MJD_SCD30_TEMPERATURE_OFFSET_MIN) {
        f_retval = ESP_ERR_INVALID_ARG;
        ESP_LOGE(TAG, "%s(). ABORT. invalid input param value | err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Main
     */
    uint16_t word = param_data; // word

    f_retval = _send_cmd(param_ptr_config, MJD_SCD30_CMD_TEMPERATURE_OFFSET, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _send_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Emit Event: Configuration Changed
     */
    _emit_event_configuration_changed();

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Get Temperature Offset
 * @doc mjd_scd30_defs.h
 *
 * @return
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_get_temperature_offset(const mjd_scd30_config_t* param_ptr_config, uint16_t* param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */

    /*
     * Main
     */
    uint16_t word; // word

    f_retval = _receive_cmd(param_ptr_config, MJD_SCD30_CMD_TEMPERATURE_OFFSET, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _receive_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // Transform
    *param_data = word;

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Set Altitude Compensation Offset
 * @doc mjd_scd30_defs.h
 *
 * @param param_data unit=meters. Height over sea level in meters above 0. param_data is a signed int by design so I can detect invalid negative numbers!
 *
 * @doc Current default value = 10 for 10 meters (= the altitude above sea level of the city Antwerp, Belgium, Europe).
 *      The value must be adapted for your region.
 *
 * @important This altitude value is disregarded when an ambient pressure is given to the sensor when reading a measurement.
 *
 * Measurements of CO2 concentration based on the NDIR principle are influenced by altitude.
 * SCD30 offers to compensate deviations due to altitude.
 *
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_set_altitude_compensation(const mjd_scd30_config_t* param_ptr_config, int16_t param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */
    if (param_data < MJD_SCD30_ALTITUDE_MIN) {
        f_retval = ESP_ERR_INVALID_ARG;
        ESP_LOGE(TAG, "%s(). ABORT. invalid input param value | err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Main
     */
    uint16_t word = param_data; // word

    f_retval = _send_cmd(param_ptr_config, MJD_SCD30_CMD_ALTITUDE_COMPENSATION, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _send_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Emit Event: Configuration Changed
     */
    _emit_event_configuration_changed();

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Get Altitude Compensation Offset
 * @doc mjd_scd30_defs.h
 *
 * @return
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_get_altitude_compensation(const mjd_scd30_config_t* param_ptr_config, uint16_t* param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */

    /*
     * Main
     */
    uint16_t word; // word

    f_retval = _receive_cmd(param_ptr_config, MJD_SCD30_CMD_ALTITUDE_COMPENSATION, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _receive_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // Transform
    *param_data = word;

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Get Firmware Version
 * @doc mjd_scd30_defs.h
 *
 * @return string "<MSByte>.<LSByte>"
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_get_firmware_version(const mjd_scd30_config_t * param_ptr_config, char * param_ptr_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */

    /*
     * Main
     */
    uint16_t word; // word

    f_retval = _receive_cmd(param_ptr_config, MJD_SCD30_CMD_GET_FIRMWARE_VERSION, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _receive_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // Transform
    sprintf(param_ptr_data, "%u.%u", MJD_HIBYTE(word), MJD_LOBYTE(word));

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Soft Reset
 * @doc mjd_scd30_defs.h
 *
 * How fast is the device available again after a soft reset (a power-off-on cycle takes 2 seconds).
 *   ASSUME: after 1 sec. TODO Obtain official value from Sensirion (iznot documented in datasheet).
 *
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_soft_reset(const mjd_scd30_config_t* param_ptr_config) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */

    /*
     * Main
     */
    f_retval = _send_cmd(param_ptr_config, MJD_SCD30_CMD_SOFT_RESET, NULL, 0);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _send_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    _delay_millisec(1000);

    /*
     * Emit Event: Configuration Changed
     */
    _emit_event_configuration_changed();

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * mjd_scd30_log_device_parameters()
 *
 * @doc mjd_scd30_config_t
 *
 *********************************************************************************/
esp_err_t mjd_scd30_log_device_parameters(mjd_scd30_config_t* param_ptr_config) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    ESP_LOGI(TAG, "LOG the I2C params:");
    ESP_LOGI(TAG, "  manage_i2c_driver:     %u", param_ptr_config->manage_i2c_driver);
    ESP_LOGI(TAG, "  i2c_port_num:          %u", param_ptr_config->i2c_port_num);
    ESP_LOGI(TAG, "  i2c_slave_addr:        0x%02X (%u)", param_ptr_config->i2c_slave_addr,
            param_ptr_config->i2c_slave_addr);
    ESP_LOGI(TAG, "  i2c_scl_gpio_num:      %u", param_ptr_config->i2c_scl_gpio_num);
    ESP_LOGI(TAG, "  i2c_sda_gpio_num:      %u", param_ptr_config->i2c_sda_gpio_num);
    ESP_LOGI(TAG, "  i2c_max_ticks_to_wait: %u", param_ptr_config->i2c_max_ticks_to_wait);

    ESP_LOGI(TAG, "Log the SCD30 Device Params (*Read again from registers*):");

    uint16_t measurement_interval = 0;
    f_retval = mjd_scd30_cmd_get_measurement_interval(param_ptr_config, &measurement_interval);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. mjd_scd30_cmd_get_measurement_interval() failed | err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    ESP_LOGI(TAG, "  measurement_interval: %u (seconds)", measurement_interval);

    mjd_scd30_data_ready_status_t data_ready_status;
    f_retval = mjd_scd30_cmd_get_data_ready_status(param_ptr_config, &data_ready_status);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. mjd_scd30_cmd_get_data_ready_status() failed | err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    ESP_LOGI(TAG, "  data_ready_status: %u (boolean)", data_ready_status);

    mjd_scd30_asc_automatic_self_calibration_t automatic_self_calibration = 0;
    f_retval = mjd_scd30_cmd_get_automatic_self_calibration(param_ptr_config, &automatic_self_calibration);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. mjd_scd30_cmd_get_automatic_self_calibration() failed | err %i (%s)", __FUNCTION__,
                f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    ESP_LOGI(TAG, "  automatic_self_calibration: %u (boolean)", automatic_self_calibration);

    uint16_t forced_recalibration_value = 0;
    f_retval = mjd_scd30_cmd_get_forced_recalibration_value(param_ptr_config, &forced_recalibration_value);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. mjd_scd30_cmd_get_forced_recalibration_value() failed | err %i (%s)", __FUNCTION__,
                f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    ESP_LOGI(TAG, "  forced_recalibration_value: %u (CO2 ppm)", forced_recalibration_value);

    uint16_t temperature_offset = 0;
    f_retval = mjd_scd30_cmd_get_temperature_offset(param_ptr_config, &temperature_offset);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. mjd_scd30_cmd_get_temperature_offset() failed | err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    ESP_LOGI(TAG, "  temperature_offset: %u (x 0.01°C)", temperature_offset);

    uint16_t altitude = 0;
    f_retval = mjd_scd30_cmd_get_altitude_compensation(param_ptr_config, &altitude);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. mjd_scd30_cmd_get_altitude_compensation() failed | err %i (%s)", __FUNCTION__,
                f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    ESP_LOGI(TAG, "  altitude: %u (meters)", altitude);

    char firmware_version[8];
    f_retval = mjd_scd30_cmd_get_firmware_version(param_ptr_config, firmware_version);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. mjd_scd30_cmd_get_firmware_version() failed | err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }
    ESP_LOGI(TAG, "  firmware_version: %s", firmware_version);

    // DEVTEMP
    /////mjd_rtos_wait_forever();

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Trigger Continuous Measurement With Optional Ambient Pressure Compensation
 * @doc mjd_scd30_defs.h
 *
 * @param param_data Unit=mBar. range: 0 & [700 … 1400]. param_data is a signed int by design so I can detect invalid negative numbers!
 *
 * The CO2 measurement value can be compensated for ambient pressure by feeding the pressure value in mBar to the sensor.
 * @doc Setting the argument to zero will deactivate the ambient pressure compensation.
 *
 * PS The old techdoc mentions max 1200 mBar. The latest techdocs mentions max 1400 mBar.
 *
 * The average barometric pressure in Antwerp is 1020mBar.
 *
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_trigger_continuous_measurement(const mjd_scd30_config_t* param_ptr_config, int16_t param_data) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */
    if (param_data != MJD_SCD30_AMBIENT_PRESSURE_DISABLED
            && (param_data < MJD_SCD30_AMBIENT_PRESSURE_MIN || param_data > MJD_SCD30_AMBIENT_PRESSURE_MAX))
            {
        f_retval = ESP_ERR_INVALID_ARG;
        ESP_LOGE(TAG, "%s(). ABORT. invalid input param value | err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Main
     */
    uint16_t word = param_data; // word

    f_retval = _send_cmd(param_ptr_config, MJD_SCD30_CMD_TRIGGER_CONTINUOUS_MEASUREMENT, &word, 1);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _send_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Stop Continuous Measurement
 * @doc mjd_scd30_defs.h
 *
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_stop_continuous_measurement(const mjd_scd30_config_t* param_ptr_config) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */

    /*
     * Main
     */
    f_retval = _send_cmd(param_ptr_config, MJD_SCD30_CMD_STOP_CONTINUOUS_MEASUREMENT, NULL, 0);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _send_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * CMD Read Measurement
 * @doc mjd_scd30_defs.h
 *
 * @return esp_err_t
 *
 * @important Ignore the 1st and 2nd reading after the settings of the device have changed,
 *            or a Soft Reset command was executed. Return ESP_ERR_INVALID_RESPONSE.
 *            In these cases, the readings 'sometimes' return 0.0 ppm or a too low (but valid) value.
 *            The Temp & Humid readings are always correct though...
 *            Make sure to effectively read the 1st and 2nd measurement via I2C but ignore the results (opposed to not reading the measurements at all).
 *
 * @important Always return ESP_ERR_INVALID_RESPONSE for a reading outside the range [_MJD_SCD30_CO2_VALID_VALUE_MIN,_MJD_SCD30_CO2_VALID_VALUE_MAX].
 *
 * Raw bytes from device:
 Byte1: CO2 concentration MMSB
 Byte2: CO2 concentration MLSB
 Byte3: CRC
 Byte4: CO2 concentration LMSB
 Byte5: CO2 concentration LLSB
 Byte6: CRC
 Byte7: Temperature MMSB
 Byte8: Temperature MLSB
 Byte9: CRC
 Byte10: Temperature LMSB
 Byte11: Temperature LLSB
 Byte12: CRC
 Byte13: Humidity MMSB
 Byte14: Humidity MLSB
 Byte15: CRC
 Byte16: Humidity LMSB
 Byte17: Humidity LLSB
 Byte18: CRC
 *
 *
 *********************************************************************************/
esp_err_t mjd_scd30_cmd_read_measurement(const mjd_scd30_config_t* param_ptr_config, mjd_scd30_data_t* param_ptr_data)
{
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     */

    /*
     * Main
     */
    uint16_t words[6]; // u16!

    f_retval = _receive_cmd(param_ptr_config, MJD_SCD30_CMD_READ_MEASUREMENT, words, ARRAY_SIZE(words));
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT _receive_cmd() err %i (%s)", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    ESP_LOGD(TAG, "%s(). Dump received data & Save raw data", __FUNCTION__);
    for (uint32_t j = 0; j < ARRAY_SIZE(words); j++) {
        ESP_LOGD(TAG, "  words[%u]: 0x%04X %4u", j, words[j], words[j]);
        param_ptr_data->raw_data[j] = words[j];
    }

    /*
     * Reject Read#1 and Read#2
     */
    _nbr_of_cmd_read_measurements++;
    if (_nbr_of_cmd_read_measurements < MJD_SCD30_THIRD_CMD_READ_MEASUREMENT_IS_VALID) {
        f_retval = ESP_ERR_INVALID_RESPONSE;
        ESP_LOGE(TAG,
                "%s(). ABORT Ignore the 1st and 2nd measurement reading. The values are sometimes wrong || err %i (%s)",
                __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /**
     * Conversions & Calculations
     *
     * @datasheet CO2 ppm, Relative Humidity, Temperature Celsius & Fahrenheit.
     *
     * @doc Temperature Celsius to Fahenheit: °F = (°C * 1.8) + 32.0
     *
     * @pdf Dew point formula @ "Sensirion_Humidity_Sensors_at_a_Glance.pdf"
     *   Inputs:
     *      td: dew point temperature in °C
     *      t:  actual temperature in °C
     *      RH: actual relative humidity in %
     *      m:  17.62
     *      Tn  243.12 °C
     *   Formula:
     *      H = (log10(RH)-2.0)/0.4343+(17.62*t)/(243.12+t);
     *      td = 243.12*H/(17.62-H);
     */
    uint32_t temp_uint32;

    temp_uint32 = ((uint32_t) words[0] << 16) | (uint32_t) words[1];
    param_ptr_data->co2_ppm = *(float*) &temp_uint32;

    temp_uint32 = ((uint32_t) words[2] << 16) | (uint32_t) words[3];
    param_ptr_data->temperature_celsius = *(float*) &temp_uint32;

    param_ptr_data->temperature_fahrenheit = param_ptr_data->temperature_celsius * 1.8 + 32.0;

    temp_uint32 = ((uint32_t) words[4] << 16) | (uint32_t) words[5];
    param_ptr_data->relative_humidity = *(float*) &temp_uint32;

    float helper_dew_point_celsius = (log10(param_ptr_data->relative_humidity) - 2.0) / 0.4343
            + (17.62 * param_ptr_data->temperature_celsius) / (243.12 + param_ptr_data->temperature_celsius);
    param_ptr_data->dew_point_celsius = 243.12 * helper_dew_point_celsius / (17.62 - helper_dew_point_celsius);

    float helper_dew_point_fahrenheit = (log10(param_ptr_data->relative_humidity) - 2.0) / 0.4343
            + (17.62 * param_ptr_data->temperature_fahrenheit) / (243.12 + param_ptr_data->temperature_fahrenheit);
    param_ptr_data->dew_point_fahrenheit = 243.12 * helper_dew_point_fahrenheit / (17.62 - helper_dew_point_fahrenheit);

    /*****
     * Return EU EN13779 Indoor air quality (IDA) data
     */
    param_ptr_data->eu_ida_category = mjd_scd30_compute_eu_ida_category(param_ptr_data->co2_ppm);

    f_retval = mjd_scd30_get_ida_category_details(param_ptr_data->eu_ida_category,
            param_ptr_data->eu_ida_category_code, param_ptr_data->eu_ida_category_desc);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). ABORT. mjd_scd30_compute_get_ida_category_details() | err %i (%s)", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Save extra context data
     */
    param_ptr_data->measurement_interval = param_ptr_config->measurement_interval;

    /*
     * Reject invalid values -> throw error!
     */
    if ((param_ptr_data->co2_ppm < _MJD_SCD30_CO2_VALID_VALUE_MIN)
            || (param_ptr_data->co2_ppm > _MJD_SCD30_CO2_VALID_VALUE_MAX)) {
        f_retval = ESP_ERR_INVALID_RESPONSE;
        ESP_LOGE(TAG, "%s(). ABORT param_ptr_data->co2_ppm invalid value %f || err %i (%s)", __FUNCTION__,
                param_ptr_data->co2_ppm, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * mjd_scd30_init()
 *
 * @important This init includes running
 *     a) The Cmd Stop Continuous Measurement. That might have been active from an earlier run. Disable it to save power.
 *     b) The Cmd SoftReset after installing the ESP32 I2C Driver, else the subsequent I2C actions will sometimes NOT WORK properly.
 *
 *********************************************************************************/
esp_err_t mjd_scd30_init(mjd_scd30_config_t* param_ptr_config) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    /*
     * Validate params
     *
     */
    if (param_ptr_config->i2c_scl_gpio_num == -1 || param_ptr_config->i2c_sda_gpio_num == -1) {
        f_retval = ESP_FAIL;
        ESP_LOGE(TAG, "%s(). ABORT. i2c_scl_gpio_num or i2c_sda_gpio_num is not initialized | err %i (%s)", __FUNCTION__,
                f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * I2C
     *
     * @important The SCD30 breakout board does not contain a 10K pullup for the SCL & SDA pins (which is a good thing)
     *              so the MCU's internal pullups for these pins must be ENabled,
     *              or wire up some external 4.7K pullup resistors on the I2C Bus.
     */
    if (param_ptr_config->manage_i2c_driver == true) {
        i2c_config_t i2c_conf =
                    { 0 };
        i2c_conf.mode = I2C_MODE_MASTER;
        i2c_conf.scl_io_num = param_ptr_config->i2c_scl_gpio_num;
        i2c_conf.sda_io_num = param_ptr_config->i2c_sda_gpio_num;
        i2c_conf.sda_pullup_en = GPIO_PULLUP_ENABLE; // @important
        i2c_conf.scl_pullup_en = GPIO_PULLUP_ENABLE; // @important
        i2c_conf.master.clk_speed = MJD_SCD30_I2C_MASTER_FREQ_HZ;
        f_retval = i2c_param_config(param_ptr_config->i2c_port_num, &i2c_conf);
        if (f_retval != ESP_OK) {
            ESP_LOGE(TAG, "%s(). ABORT. i2c_param_config() | err %i (%s)", __FUNCTION__, f_retval,
                    esp_err_to_name(f_retval));
            // GOTO
            goto cleanup;
        }
        f_retval = i2c_set_timeout(param_ptr_config->i2c_port_num, MJD_SCD30_I2C_SLAVE_TIMEOUT_MAXVAL); // @important clock-strethcing
        if (f_retval != ESP_OK) {
            ESP_LOGE(TAG, "%s(). ABORT. i2c_set_timeout() | err %i (%s)", __FUNCTION__, f_retval,
                    esp_err_to_name(f_retval));
            // GOTO
            goto cleanup;
        }

        f_retval = i2c_driver_install(param_ptr_config->i2c_port_num, I2C_MODE_MASTER, MJD_SCD30_I2C_MASTER_RX_BUF_DISABLE,
        MJD_SCD30_I2C_MASTER_TX_BUF_DISABLE, MJD_SCD30_I2C_MASTER_INTR_FLAG_NONE);
        if (f_retval != ESP_OK) {
            ESP_LOGE(TAG, "%s(). ABORT. i2c_driver_install() | err %i (%s)", __FUNCTION__, f_retval,
                    esp_err_to_name(f_retval));
            // GOTO
            goto cleanup;
        }
    }

    // DEVTEMP
    /////mjd_rtos_wait_forever();

    /*
     * Soft Reset AFTER setting extra props and modes

     * @important Reset the SCD30 to ensure the sensor is in a stable and active state
     *            before we start using it. It might have gone unresponsive in a previous run!
     *
     */
    f_retval = mjd_scd30_cmd_soft_reset(param_ptr_config);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). mjd_scd30_cmd_soft_reset() err %i %s", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Set modes and extra prop(s)
     *
     * @important Run the command "Stop Continuous Measurement". CM might have been active from a previous run
     *           that was interrupted (@example the ESP32 board was reset).
     *
     * @important Many settings are stored in NVRAM on the SCD30 sensor. It is vital to set many of them again
     *            right here in order to override the settings that were written with other/older ESP32 firmware.
     *
     */
    f_retval = mjd_scd30_cmd_stop_continuous_measurement(param_ptr_config);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). mjd_scd30_cmd_stop_continuous_measurement() err %i %s", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    f_retval = mjd_scd30_cmd_set_measurement_interval(param_ptr_config, param_ptr_config->measurement_interval);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). mjd_scd30_cmd_set_measurement_interval() err %i %s", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    f_retval = mjd_scd30_cmd_set_temperature_offset(param_ptr_config, param_ptr_config->temperature_offset);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). mjd_scd30_cmd_set_temperature_offset() err %i %s", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    f_retval = mjd_scd30_cmd_set_altitude_compensation(param_ptr_config, param_ptr_config->altitude_compensation);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). mjd_scd30_cmd_set_altitude_compensation() err %i %s", __FUNCTION__, f_retval,
                esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    /*
     * Logging
     */
    f_retval = _log_config(param_ptr_config);
    if (f_retval != ESP_OK) {
        ESP_LOGE(TAG, "%s(). _log_config() err %i %s", __FUNCTION__, f_retval, esp_err_to_name(f_retval));
        // GOTO
        goto cleanup;
    }

    // DEVTEMP
    /////mjd_rtos_wait_forever();
    // LABEL
    cleanup: ;

    return f_retval;
}

/*********************************************************************************
 * mjd_scd30_deinit()
 *
 *********************************************************************************/
esp_err_t mjd_scd30_deinit(const mjd_scd30_config_t* param_ptr_config) {
    ESP_LOGD(TAG, "%s()", __FUNCTION__);

    esp_err_t f_retval = ESP_OK;

    _log_config(param_ptr_config);

    /*
     * I2C Driver
     */
    if (param_ptr_config->manage_i2c_driver == true) {
        f_retval = i2c_driver_delete(param_ptr_config->i2c_port_num);
        if (f_retval != ESP_OK) {
            ESP_LOGE(TAG, "%s(). ABORT. i2c_driver_delete() | err %i (%s)", __FUNCTION__, f_retval,
                    esp_err_to_name(f_retval));
            // GOTO
            goto cleanup;
        }
    }

    // LABEL
    cleanup: ;

    return f_retval;
}
